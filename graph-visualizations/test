digraph clusterfnc {
	graph [label=fnc]
	1 [label="def get_smooth_closed_cubic_bezier_handle_points(anchors: Point3DLike_Array...
"]
	subgraph clusterget_smooth_closed_cubic_bezier_handle_points {
		graph [label=get_smooth_closed_cubic_bezier_handle_points]
		3 [label="\"\"\"Special case of :func:`get_smooth_cubic_bezier_handle_points`,
    when the ``anchors`` form a closed loop.

    .. note::
        A system of equations must be solved to get the first handles of
        every Bézier curve (referred to as :math:`H_1`).
        Then :math:`H_2` (the second handles) can be obtained separately.

        .. seealso::
            The equations were obtained from:

            * `Conditions on control points for continuous curvature. (2016). Jaco Stuifbergen. <http://www.jacos.nl/jacos_html/spline/theory/theory_2.html>`_

        In general, if there are :math:`N+1` anchors, there will be :math:`N` Bézier curves
        and thus :math:`N` pairs of handles to find. We must solve the following
        system of equations for the 1st handles (example for :math:`N = 5`):

        .. math::
            \\begin{pmatrix}
                4 & 1 & 0 & 0 & 1 \\\\
                1 & 4 & 1 & 0 & 0 \\\\
                0 & 1 & 4 & 1 & 0 \\\\
                0 & 0 & 1 & 4 & 1 \\\\
                1 & 0 & 0 & 1 & 4
            \\end{pmatrix}
            \\begin{pmatrix}
                H_{1,0} \\\\
                H_{1,1} \\\\
                H_{1,2} \\\\
                H_{1,3} \\\\
                H_{1,4}
            \\end{pmatrix}
            =
            \\begin{pmatrix}
                4A_0 + 2A_1 \\\\
                4A_1 + 2A_2 \\\\
                4A_2 + 2A_3 \\\\
                4A_3 + 2A_4 \\\\
                4A_4 + 2A_5
            \\end{pmatrix}

        which will be expressed as :math:`RH_1 = D`.

        :math:`R` is almost a tridiagonal matrix, so we could use Thomas' algorithm.

        .. seealso::
            `Tridiagonal matrix algorithm. Wikipedia. <https://en.wikipedia.org/wiki/Tridiagonal_matrix_algorithm>`_

        However, :math:`R` has ones at the opposite corners. A solution to this is
        the first decomposition proposed in the link below, with :math:`\\alpha = 1`:

        .. seealso::
            `Tridiagonal matrix algorithm # Variants. Wikipedia. <https://en.wikipedia.org/wiki/Tridiagonal_matrix_algorithm#Variants>`_

        .. math::
            R
            =
            \\begin{pmatrix}
                4 & 1 & 0 & 0 & 1 \\\\
                1 & 4 & 1 & 0 & 0 \\\\
                0 & 1 & 4 & 1 & 0 \\\\
                0 & 0 & 1 & 4 & 1 \\\\
                1 & 0 & 0 & 1 & 4
            \\end{pmatrix}
            &=
            \\begin{pmatrix}
                3 & 1 & 0 & 0 & 0 \\\\
                1 & 4 & 1 & 0 & 0 \\\\
                0 & 1 & 4 & 1 & 0 \\\\
                0 & 0 & 1 & 4 & 1 \\\\
                0 & 0 & 0 & 1 & 3
            \\end{pmatrix}
            +
            \\begin{pmatrix}
                1 & 0 & 0 & 0 & 1 \\\\
                0 & 0 & 0 & 0 & 0 \\\\
                0 & 0 & 0 & 0 & 0 \\\\
                0 & 0 & 0 & 0 & 0 \\\\
                1 & 0 & 0 & 0 & 1
            \\end{pmatrix}
            \\\\
            &
            \\\\
            &=
            \\begin{pmatrix}
                3 & 1 & 0 & 0 & 0 \\\\
                1 & 4 & 1 & 0 & 0 \\\\
                0 & 1 & 4 & 1 & 0 \\\\
                0 & 0 & 1 & 4 & 1 \\\\
                0 & 0 & 0 & 1 & 3
            \\end{pmatrix}
            +
            \\begin{pmatrix}
                1 \\\\
                0 \\\\
                0 \\\\
                0 \\\\
                1
            \\end{pmatrix}
            \\begin{pmatrix}
                1 & 0 & 0 & 0 & 1
            \\end{pmatrix}
            \\\\
            &
            \\\\
            &=
            T + uv^t

        We decompose :math:`R = T + uv^t`, where :math:`T` is a tridiagonal matrix, and
        :math:`u, v` are :math:`N`-D vectors such that :math:`u_0 = u_{N-1} = v_0 = v_{N-1} = 1`,
        and :math:`u_i = v_i = 0, \\forall i \\in \\{1, ..., N-2\\}`.

        Thus:

        .. math::
            RH_1 &= D \\\\
            \\Rightarrow (T + uv^t)H_1 &= D

        If we find a vector :math:`q` such that :math:`Tq = u`:

        .. math::
            \\Rightarrow (T + Tqv^t)H_1 &= D \\\\
            \\Rightarrow T(I + qv^t)H_1 &= D \\\\
            \\Rightarrow H_1 &= (I + qv^t)^{-1} T^{-1} D

        According to Sherman-Morrison's formula:

        .. seealso::
            `Sherman-Morrison's formula. Wikipedia. <https://en.wikipedia.org/wiki/Sherman%E2%80%93Morrison_formula>`_

        .. math::
            (I + qv^t)^{-1} = I - \\frac{1}{1 + v^tq} qv^t

        If we find :math:`Y = T^{-1} D`, or in other words, if we solve for
        :math:`Y` in :math:`TY = D`:

        .. math::
            H_1 &= (I + qv^t)^{-1} T^{-1} D \\\\
            &= (I + qv^t)^{-1} Y \\\\
            &= (I - \\frac{1}{1 + v^tq} qv^t) Y \\\\
            &= Y - \\frac{1}{1 + v^tq} qv^tY

        Therefore, we must solve for :math:`q` and :math:`Y` in :math:`Tq = u` and :math:`TY = D`.
        As :math:`T` is now tridiagonal, we shall use Thomas' algorithm.

        Define:

        *   :math:`a = [a_0, \\ a_1, \\ ..., \\ a_{N-2}]` as :math:`T`'s lower diagonal of :math:`N-1` elements,
            such that :math:`a_0 = a_1 = ... = a_{N-2} = 1`, so this diagonal is filled with ones;
        *   :math:`b = [b_0, \\ b_1, \\ ..., \\ b_{N-2}, \\ b_{N-1}]` as :math:`T`'s main diagonal of :math:`N` elements,
            such that :math:`b_0 = b_{N-1} = 3`, and :math:`b_1 = b_2 = ... = b_{N-2} = 4`;
        *   :math:`c = [c_0, \\ c_1, \\ ..., \\ c_{N-2}]` as :math:`T`'s upper diagonal of :math:`N-1` elements,
            such that :math:`c_0 = c_1 = ... = c_{N-2} = 1`: this diagonal is also filled with ones.

        If, according to Thomas' algorithm, we define:

        .. math::
            c'_0 &= \\frac{c_0}{b_0} & \\\\
            c'_i &= \\frac{c_i}{b_i - a_{i-1} c'_{i-1}}, & \\quad \\forall i \\in \\{1, ..., N-2\\} \\\\
            & & \\\\
            u'_0 &= \\frac{u_0}{b_0} & \\\\
            u'_i &= \\frac{u_i - a_{i-1} u'_{i-1}}{b_i - a_{i-1} c'_{i-1}}, & \\quad \\forall i \\in \\{1, ..., N-1\\} \\\\
            & & \\\\
            D'_0 &= \\frac{1}{b_0} D_0 & \\\\
            D'_i &= \\frac{1}{b_i - a_{i-1} c'_{i-1}} (D_i - a_{i-1} D'_{i-1}), & \\quad \\forall i \\in \\{1, ..., N-1\\}

        Then:

        .. math::
            c'_0     &= \\frac{1}{3} & \\\\
            c'_i     &= \\frac{1}{4 - c'_{i-1}}, & \\quad \\forall i \\in \\{1, ..., N-2\\} \\\\
            & & \\\\
            u'_0     &= \\frac{1}{3} & \\\\
            u'_i     &= \\frac{-u'_{i-1}}{4 - c'_{i-1}} = -c'_i u'_{i-1}, & \\quad \\forall i \\in \\{1, ..., N-2\\} \\\\
            u'_{N-1} &= \\frac{1 - u'_{N-2}}{3 - c'_{N-2}} & \\\\
            & & \\\\
            D'_0     &= \\frac{1}{3} (4A_0 + 2A_1) & \\\\
            D'_i     &= \\frac{1}{4 - c'_{i-1}} (4A_i + 2A_{i+1} - D'_{i-1}) & \\\\
            &= c_i (4A_i + 2A_{i+1} - D'_{i-1}), & \\quad \\forall i \\in \\{1, ..., N-2\\} \\\\
            D'_{N-1} &= \\frac{1}{3 - c'_{N-2}} (4A_{N-1} + 2A_N - D'_{N-2}) &

        Finally, we can do Backward Substitution to find :math:`q` and :math:`Y`:

        .. math::
            q_{N-1} &= u'_{N-1} & \\\\
            q_i     &= u'_{i} - c'_i q_{i+1}, & \\quad \\forall i \\in \\{0, ..., N-2\\} \\\\
            & & \\\\
            Y_{N-1} &= D'_{N-1} & \\\\
            Y_i     &= D'_i - c'_i Y_{i+1},   & \\quad \\forall i \\in \\{0, ..., N-2\\}

        With those values, we can finally calculate :math:`H_1 = Y - \\frac{1}{1 + v^tq} qv^tY`.
        Given that :math:`v_0 = v_{N-1} = 1`, and :math:`v_1 = v_2 = ... = v_{N-2} = 0`, its dot products
        with :math:`q` and :math:`Y` are respectively :math:`v^tq = q_0 + q_{N-1}` and
        :math:`v^tY = Y_0 + Y_{N-1}`. Thus:

        .. math::
            H_1 = Y - \\frac{1}{1 + q_0 + q_{N-1}} q(Y_0 + Y_{N-1})

        Once we have :math:`H_1`, we can get :math:`H_2` (the array of second handles) as follows:

        .. math::
            H_{2, i}   &= 2A_{i+1} - H_{1, i+1}, & \\quad \\forall i \\in \\{0, ..., N-2\\} \\\\
            H_{2, N-1} &= 2A_0 - H_{1, 0} &

        Because the matrix :math:`R` always follows the same pattern (and thus :math:`T, u, v` as well),
        we can define a memo list for :math:`c'` and :math:`u'` to avoid recalculation. We cannot
        memoize :math:`D` and :math:`Y`, however, because they are always different matrices. We
        cannot make a memo for :math:`q` either, but we can calculate it faster because :math:`u'`
        can be memoized.

    Parameters
    ----------
    anchors
        Anchors of a closed cubic spline.

    Returns
    -------
    :class:`tuple` [:class:`~.Point3D_Array`, :class:`~.Point3D_Array`]
        A tuple of two arrays: one containing the 1st handle for every curve in
        the closed cubic spline, and the other containing the 2nd handles.
    \"\"\"
A = np.asarray(anchors)
N = A.shape[0] - 1
dim = A.shape[1]
len_memo = CP_CLOSED_MEMO.size
if len_memo < N - 1:
"]
		"3_calls" [label="np.asarray" shape=box]
		3 -> "3_calls" [label=calls style=dashed]
		4 [label="cp = np.empty(N - 1)
up = np.empty(N - 1)
cp[:len_memo] = CP_CLOSED_MEMO
up[:len_memo] = UP_CLOSED_MEMO
"]
		"4_calls" [label="np.empty
np.empty" shape=box]
		4 -> "4_calls" [label=calls style=dashed]
		7 [label="for i in range(len_memo, N - 1):
"]
		8 [label="cp[i] = 1 / (4 - cp[i - 1])
up[i] = -cp[i] * up[i - 1]
"]
		8 -> 7 [label=""]
		7 -> 8 [label="range(len_memo, N - 1)"]
		9 [label="CP_CLOSED_MEMO = cp
UP_CLOSED_MEMO = up
"]
		5 [label="cp_last_division = 1 / (3 - cp[N - 2])
up_last = cp_last_division * (1 - up[N - 2])
q = np.empty((N, dim))
q[N - 1] = up_last
"]
		"5_calls" [label="np.empty" shape=box]
		5 -> "5_calls" [label=calls style=dashed]
		10 [label="for i in range(N - 2, -1, -1):
"]
		11 [label="q[i] = up[i] - cp[i] * q[i + 1]
"]
		11 -> 10 [label=""]
		10 -> 11 [label="range(N - 2, -1, -1)"]
		12 [label="Dp = np.empty((N, dim))
AUX = 4 * A[:N] + 2 * A[1:]
Dp[0] = AUX[0] / 3
"]
		"12_calls" [label="np.empty" shape=box]
		12 -> "12_calls" [label=calls style=dashed]
		13 [label="for i in range(1, N - 1):
"]
		14 [label="Dp[i] = cp[i] * (AUX[i] - Dp[i - 1])
"]
		14 -> 13 [label=""]
		13 -> 14 [label="range(1, N - 1)"]
		15 [label="Dp[N - 1] = cp_last_division * (AUX[N - 1] - Dp[N - 2])
Y = Dp
"]
		16 [label="for i in range(N - 2, -1, -1):
"]
		17 [label="Y[i] = Dp[i] - cp[i] * Y[i + 1]
"]
		17 -> 16 [label=""]
		16 -> 17 [label="range(N - 2, -1, -1)"]
		18 [label="H1 = Y - 1 / (1 + q[0] + q[N - 1]) * q * (Y[0] + Y[N - 1])
H2 = np.empty((N, dim))
H2[0:N - 1] = 2 * A[1:N] - H1[1:N]
H2[N - 1] = 2 * A[N] - H1[0]
return H1, H2
"]
		"18_calls" [label="np.empty" shape=box]
		18 -> "18_calls" [label=calls style=dashed]
		16 -> 18 [label=""]
		15 -> 16 [label=""]
		13 -> 15 [label=""]
		12 -> 13 [label=""]
		10 -> 12 [label=""]
		5 -> 10 [label=""]
		9 -> 5 [label=""]
		7 -> 9 [label=""]
		4 -> 7 [label=""]
		3 -> 4 [label="len_memo < N - 1"]
		6 [label="cp = CP_CLOSED_MEMO[:N - 1]
up = UP_CLOSED_MEMO[:N - 1]
"]
		6 -> 5 [label=""]
		3 -> 6 [label="(len_memo >= N - 1)"]
	}
}
